<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>stalker.models.task.Task &mdash; Stalker 0.2.13.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.2.13.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="Stalker 0.2.13.3 documentation" href="../index.html" />
    <link rel="next" title="stalker.models.task.TaskDependency" href="stalker.models.task.TaskDependency.html" />
    <link rel="prev" title="stalker.models.tag.Tag" href="stalker.models.tag.Tag.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body role="document">

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="stalker.models.task.TaskDependency.html" title="stalker.models.task.TaskDependency"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="stalker.models.tag.Tag.html" title="stalker.models.tag.Tag"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Stalker 0.2.13.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="stalker-models-task-task">
<h1>stalker.models.task.Task<a class="headerlink" href="#stalker-models-task-task" title="Permalink to this headline">¶</a></h1>
<p class="graphviz">
digraph inheritancec854da7c82 {
rankdir=LR;
size=&quot;8.0, 12.0&quot;;
  &quot;Base&quot; [shape=box,style=&quot;setlinewidth(0.5)&quot;,fontsize=10,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,height=0.25];
  &quot;ORMClass&quot; -&gt; &quot;Base&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;DAGMixin&quot; [shape=box,style=&quot;setlinewidth(0.5)&quot;,fontsize=10,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,height=0.25];
  &quot;DateRangeMixin&quot; [style=&quot;setlinewidth(0.5)&quot;,URL=&quot;stalker.models.mixins.DateRangeMixin.html#stalker.models.mixins.DateRangeMixin&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,height=0.25,shape=box,fontsize=10];
  &quot;Entity&quot; [style=&quot;setlinewidth(0.5)&quot;,URL=&quot;stalker.models.entity.Entity.html#stalker.models.entity.Entity&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,height=0.25,shape=box,fontsize=10];
  &quot;SimpleEntity&quot; -&gt; &quot;Entity&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;ORMClass&quot; [shape=box,style=&quot;setlinewidth(0.5)&quot;,fontsize=10,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,height=0.25];
  &quot;ReferenceMixin&quot; [style=&quot;setlinewidth(0.5)&quot;,URL=&quot;stalker.models.mixins.ReferenceMixin.html#stalker.models.mixins.ReferenceMixin&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,height=0.25,shape=box,fontsize=10];
  &quot;ScheduleMixin&quot; [style=&quot;setlinewidth(0.5)&quot;,URL=&quot;stalker.models.mixins.ScheduleMixin.html#stalker.models.mixins.ScheduleMixin&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,height=0.25,shape=box,fontsize=10];
  &quot;SimpleEntity&quot; [style=&quot;setlinewidth(0.5)&quot;,URL=&quot;stalker.models.entity.SimpleEntity.html#stalker.models.entity.SimpleEntity&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,height=0.25,shape=box,fontsize=10];
  &quot;Base&quot; -&gt; &quot;SimpleEntity&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;StatusMixin&quot; [style=&quot;setlinewidth(0.5)&quot;,URL=&quot;stalker.models.mixins.StatusMixin.html#stalker.models.mixins.StatusMixin&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,height=0.25,shape=box,fontsize=10];
  &quot;Task&quot; [style=&quot;setlinewidth(0.5)&quot;,URL=&quot;#stalker.models.task.Task&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,height=0.25,shape=box,fontsize=10];
  &quot;Entity&quot; -&gt; &quot;Task&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;StatusMixin&quot; -&gt; &quot;Task&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;DateRangeMixin&quot; -&gt; &quot;Task&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;ReferenceMixin&quot; -&gt; &quot;Task&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;ScheduleMixin&quot; -&gt; &quot;Task&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;DAGMixin&quot; -&gt; &quot;Task&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
}
</p>
<dl class="class">
<dt id="stalker.models.task.Task">
<em class="property">class </em><code class="descclassname">stalker.models.task.</code><code class="descname">Task</code><span class="sig-paren">(</span><em>project=None</em>, <em>parent=None</em>, <em>depends=None</em>, <em>resources=None</em>, <em>alternative_resources=None</em>, <em>responsible=None</em>, <em>watchers=None</em>, <em>start=None</em>, <em>end=None</em>, <em>schedule_timing=1.0</em>, <em>schedule_unit='h'</em>, <em>schedule_model=None</em>, <em>schedule_constraint=0</em>, <em>bid_timing=None</em>, <em>bid_unit=None</em>, <em>is_milestone=False</em>, <em>priority=500</em>, <em>allocation_strategy='minallocated'</em>, <em>persistent_allocation=True</em>, <em>good=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="stalker.models.entity.Entity.html#stalker.models.entity.Entity" title="stalker.models.entity.Entity"><code class="xref py py-class docutils literal"><span class="pre">stalker.models.entity.Entity</span></code></a>, <a class="reference internal" href="stalker.models.mixins.StatusMixin.html#stalker.models.mixins.StatusMixin" title="stalker.models.mixins.StatusMixin"><code class="xref py py-class docutils literal"><span class="pre">stalker.models.mixins.StatusMixin</span></code></a>, <a class="reference internal" href="stalker.models.mixins.DateRangeMixin.html#stalker.models.mixins.DateRangeMixin" title="stalker.models.mixins.DateRangeMixin"><code class="xref py py-class docutils literal"><span class="pre">stalker.models.mixins.DateRangeMixin</span></code></a>, <a class="reference internal" href="stalker.models.mixins.ReferenceMixin.html#stalker.models.mixins.ReferenceMixin" title="stalker.models.mixins.ReferenceMixin"><code class="xref py py-class docutils literal"><span class="pre">stalker.models.mixins.ReferenceMixin</span></code></a>, <a class="reference internal" href="stalker.models.mixins.ScheduleMixin.html#stalker.models.mixins.ScheduleMixin" title="stalker.models.mixins.ScheduleMixin"><code class="xref py py-class docutils literal"><span class="pre">stalker.models.mixins.ScheduleMixin</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">stalker.models.mixins.DAGMixin</span></code></p>
<p>Manages Task related data.</p>
<p><strong>Introduction</strong></p>
<p>Tasks are the smallest unit of work that should be accomplished to complete
a <a class="reference internal" href="stalker.models.project.Project.html#stalker.models.project.Project" title="stalker.models.project.Project"><code class="xref py py-class docutils literal"><span class="pre">Project</span></code></a>. Tasks define a certain amount of time needed to be
spent for a purpose. They also define a complex hierarchy of relation.</p>
<p>Stalker follows and enhances the concepts stated in <a class="reference external" href="http://www.taskjuggler.org/">TaskJuggler</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.2.0: </span>References in Tasks</p>
</div>
<p class="last">Tasks can now have References.</p>
</div>
<p><strong>Initialization</strong></p>
<p>Tasks are a part of a bigger Project, that&#8217;s way a Task needs to be created
with a <a class="reference internal" href="stalker.models.project.Project.html#stalker.models.project.Project" title="stalker.models.project.Project"><code class="xref py py-class docutils literal"><span class="pre">Project</span></code></a> instance. It is possible to create a task without
a project, if it is created to be a child of another task. And it is also
possible to pass both a project and a parent task.</p>
<p>But because passing both a project and a parent task may create an
ambiguity, Stalker will raise a RuntimeWarning, if both project and task
are given and the owner project of the given parent task is different then
the supplied project instance. But again Stalker will warn the user but
will continue to use the task as the parent and will correctly use the
project of the given task as the project of the newly created task.</p>
<p>The following codes are a couple of examples for creating Task instances:</p>
<div class="highlight-python"><div class="highlight"><pre># with a project instance
&gt;&gt;&gt; from stalker import Project
&gt;&gt;&gt; project1 = Project(name=&#39;Test Project 1&#39;)  # simplified
&gt;&gt;&gt; task1 = Task(name=&#39;Schedule&#39;, project=project1)

# with a parent task
&gt;&gt;&gt; task2 = Task(name=&#39;Documentation&#39;, parent=task1)

# or both
&gt;&gt;&gt; task3 = Task(name=&#39;Test&#39;, project=project1, parent=task1)

# this will create a RuntimeWarning
&gt;&gt;&gt; project2 = Project(name=&#39;Test Project 2&#39;)
&gt;&gt;&gt; task4 = Task(name=&#39;Test&#39;, project=project2, parent=task1)
# task1 is not a # task of proj2

&gt;&gt;&gt; assert task4.project == project1
# Stalker uses the task1.project for task4

# this will also create a RuntimeError
&gt;&gt;&gt; task3 = Task(name=&#39;Failure 2&#39;) # no project no parent, this is an
                                   # orphan task.
</pre></div>
</div>
<p>Also initially Stalker will pin point the <a class="reference internal" href="#stalker.models.task.Task.start" title="stalker.models.task.Task.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a> value and then
will calculate proper <a class="reference internal" href="#stalker.models.task.Task.end" title="stalker.models.task.Task.end"><code class="xref py py-attr docutils literal"><span class="pre">end</span></code></a> and <a class="reference internal" href="#stalker.models.task.Task.duration" title="stalker.models.task.Task.duration"><code class="xref py py-attr docutils literal"><span class="pre">duration</span></code></a> values by using
the <a class="reference internal" href="#stalker.models.task.Task.schedule_timing" title="stalker.models.task.Task.schedule_timing"><code class="xref py py-attr docutils literal"><span class="pre">schedule_timing</span></code></a> and <a class="reference internal" href="#stalker.models.task.Task.schedule_unit" title="stalker.models.task.Task.schedule_unit"><code class="xref py py-attr docutils literal"><span class="pre">schedule_unit</span></code></a> attributes. But
these values (start, end and duration) are temporary values for an
unscheduled task. The final date values will be calculated by TaskJuggler
in the <cite>auto scheduling</cite> phase.</p>
<p><strong>Auto Scheduling</strong></p>
<p>Stalker uses TaskJuggler for task scheduling. After defining all the tasks,
Stalker will convert them to a single tjp file along with the recorded
<a class="reference internal" href="stalker.models.task.TimeLog.html#stalker.models.task.TimeLog" title="stalker.models.task.TimeLog"><code class="xref py py-class docutils literal"><span class="pre">TimeLog</span></code></a>s <code class="xref py py-class docutils literal"><span class="pre">Vacation</span></code>s etc. and let TaskJuggler to
solve the scheduling problem.</p>
<p>During the auto scheduling (with TaskJuggler), the calculation of task
duration, start and end dates are effected by the working hours setting of
the <a class="reference internal" href="stalker.models.studio.Studio.html#stalker.models.studio.Studio" title="stalker.models.studio.Studio"><code class="xref py py-class docutils literal"><span class="pre">Studio</span></code></a>, the effort that needs to spend for that task and the
availability of the resources assigned to the task.</p>
<p>A good practice for creating a project plan is to supply the parent/child
and dependency relation between tasks and the effort and resource
information per task and leave the start and end date calculation to
TaskJuggler.</p>
<p>The default <a class="reference internal" href="#stalker.models.task.Task.schedule_model" title="stalker.models.task.Task.schedule_model"><code class="xref py py-attr docutils literal"><span class="pre">schedule_model</span></code></a> for Stalker tasks is &#8216;effort`, the
default <a class="reference internal" href="#stalker.models.task.Task.schedule_unit" title="stalker.models.task.Task.schedule_unit"><code class="xref py py-attr docutils literal"><span class="pre">schedule_unit</span></code></a> is <code class="docutils literal"><span class="pre">hour</span></code> and the default value of
<a class="reference internal" href="#stalker.models.task.Task.schedule_timing" title="stalker.models.task.Task.schedule_timing"><code class="xref py py-attr docutils literal"><span class="pre">schedule_timing</span></code></a> is defined by the
<code class="xref py py-attr docutils literal"><span class="pre">stalker.config.Config.timing_resolution</span></code>. So for a config where the
<code class="docutils literal"><span class="pre">timing_resolution</span></code> is set to 1 hour the schedule_timing is 1.</p>
<p>It is also possible to use the <code class="docutils literal"><span class="pre">length</span></code> or <code class="docutils literal"><span class="pre">duration</span></code> values for
<a class="reference internal" href="#stalker.models.task.Task.schedule_model" title="stalker.models.task.Task.schedule_model"><code class="xref py py-attr docutils literal"><span class="pre">schedule_model</span></code></a> (set it to &#8216;effort&#8217;, &#8216;length&#8217; or &#8216;duration&#8217; to get
the desired scheduling model).</p>
<p>To convert a Task instance to a TaskJuggler compatible string use the
<code class="xref py py-attr docutils literal"><span class="pre">to_tjp`</span></code> attribute. It will try to create a good representation of
the Task by using the resources, schedule_model, schedule_timing and
schedule_constraint attributes.</p>
<p>** Alternative Resources**</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.2.5: </span>Alternative Resources</p>
</div>
<p>Stalker now supports alternative resources per task. You can specify
alternative resources by using the <a class="reference internal" href="#stalker.models.task.Task.alternative_resources" title="stalker.models.task.Task.alternative_resources"><code class="xref py py-attr docutils literal"><span class="pre">alternative_resources</span></code></a>
attribute. The number of resources and the number of alternative resources
are not related. So you can define only 1 resource and more than one
alternative resources, or you can define 2 resources and only one
alternative resource.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">As opposed to TaskJuggler alternative resources are not per resource
based. So Stalker will use the alternatives list for all of the
resources in the resources list. Per resource alternative will be
supported in future versions of Stalker.</p>
</div>
<p>Stalker will pass the data to TaskJuggler and TJ will compute a list of
resources that are assigned to the task in the report time frame and
Stalker will store the resultant list of users in
<a class="reference internal" href="#stalker.models.task.Task.computed_resources" title="stalker.models.task.Task.computed_resources"><code class="xref py py-attr docutils literal"><span class="pre">computed_resources</span></code></a> attribute.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When TaskJuggler computes the resources, the returned list may contain
resources which are not in the <a class="reference internal" href="#stalker.models.task.Task.resources" title="stalker.models.task.Task.resources"><code class="xref py py-attr docutils literal"><span class="pre">resources</span></code></a> nor in
<a class="reference internal" href="#stalker.models.task.Task.alternative_resources" title="stalker.models.task.Task.alternative_resources"><code class="xref py py-attr docutils literal"><span class="pre">alternative_resources</span></code></a> list anymore. Stalker will silently
filter those resources and will only store resources (in
<a class="reference internal" href="#stalker.models.task.Task.computed_resources" title="stalker.models.task.Task.computed_resources"><code class="xref py py-attr docutils literal"><span class="pre">computed_resources</span></code></a>) those are still available as a direct or
alternative resource to that particular task.</p>
</div>
<p>The selection strategy of the alternative resource is defined by the
<a class="reference internal" href="#stalker.models.task.Task.allocation_strategy" title="stalker.models.task.Task.allocation_strategy"><code class="xref py py-attr docutils literal"><span class="pre">allocation_strategy</span></code></a> attribute. The <cite>allocation_strategy</cite>
attribute value should be one of [minallocated, maxloaded, minloaded,
order, random]. The following description is from TaskJuggler
documentation:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>minallocated</td>
<td>Pick the resource that has the smallest allocation
factor. The allocation factor is calculated from the
various allocations of the resource across the tasks.
This is the default setting.)</td>
</tr>
<tr class="row-even"><td>maxloaded</td>
<td>Pick the available resource that has been used the
most so far.</td>
</tr>
<tr class="row-odd"><td>minloaded</td>
<td>Pick the available resource that has been used the
least so far.</td>
</tr>
<tr class="row-even"><td>order</td>
<td>Pick the first available resource from the list.</td>
</tr>
<tr class="row-odd"><td>random</td>
<td>Pick a random resource from the list.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>As in TaskJuggler the default for <a class="reference internal" href="#stalker.models.task.Task.allocation_strategy" title="stalker.models.task.Task.allocation_strategy"><code class="xref py py-attr docutils literal"><span class="pre">allocation_strategy</span></code></a> attribute is
&#8220;minallocated&#8221;.</p>
<p>Also the allocation of the resources are effected by the
<a class="reference internal" href="#stalker.models.task.Task.persistent_allocation" title="stalker.models.task.Task.persistent_allocation"><code class="xref py py-attr docutils literal"><span class="pre">persistent_allocation</span></code></a> attribute. The persistent_allocation
attribute refers to the <code class="docutils literal"><span class="pre">persistent</span></code> attribute in TJ. The documentation
of <code class="docutils literal"><span class="pre">persistent</span></code> in TJ is as follows:</p>
<blockquote>
<div>Specifies that once a resource is picked from the list of alternatives
this resource is used for the whole task. This is useful when several
alternative resources have been specified. Normally the selected resource
can change after each break. A break is an interval of at least one
timeslot where no resources were available.</div></blockquote>
<p><a class="reference internal" href="#stalker.models.task.Task.persistent_allocation" title="stalker.models.task.Task.persistent_allocation"><code class="xref py py-attr docutils literal"><span class="pre">persistent_allocation</span></code></a> attribute is True by default.</p>
<p>For a not yet scheduled task the <a class="reference internal" href="#stalker.models.task.Task.computed_resources" title="stalker.models.task.Task.computed_resources"><code class="xref py py-attr docutils literal"><span class="pre">computed_resources</span></code></a> attribute will
be the same as the <a class="reference internal" href="#stalker.models.task.Task.resources" title="stalker.models.task.Task.resources"><code class="xref py py-attr docutils literal"><span class="pre">resources</span></code></a> list. After the task is scheduled the
content of the <a class="reference internal" href="#stalker.models.task.Task.computed_resources" title="stalker.models.task.Task.computed_resources"><code class="xref py py-attr docutils literal"><span class="pre">computed_resources</span></code></a> will purely come from TJ.</p>
<p>Updating the resources list will not update the <a class="reference internal" href="#stalker.models.task.Task.computed_resources" title="stalker.models.task.Task.computed_resources"><code class="xref py py-attr docutils literal"><span class="pre">computed_resources</span></code></a>
list if the task <a class="reference internal" href="#stalker.models.task.Task.is_scheduled" title="stalker.models.task.Task.is_scheduled"><code class="xref py py-attr docutils literal"><span class="pre">is_scheduled</span></code></a>.</p>
<p><strong>Task to Task Relation</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.2.0.</span></p>
</div>
<p class="last">Task to Task Relation</p>
</div>
<p>Tasks can have child Tasks. So you can create complex relations of Tasks to
comply with your project needs.</p>
<p>A Task is called a <code class="docutils literal"><span class="pre">container</span> <span class="pre">task</span></code> if it has at least one child Task.
And it is called a <code class="docutils literal"><span class="pre">leaf</span> <span class="pre">task</span></code> if it doesn&#8217;t have any children Tasks.
Tasks which doesn&#8217;t have a parent called <code class="docutils literal"><span class="pre">root_task</span></code>.</p>
<p>As opposed to TaskJuggler where the resource information is passed through
parent to child, in Stalker the resources in a container task is
meaningless, cause the resources are defined by the child tasks.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although, the <code class="docutils literal"><span class="pre">tjp_task_template</span></code> variable is not coded in that way in
the default config, if you want to populate resource information through
children tasks as it is in TaskJuggler, you can change the
<code class="docutils literal"><span class="pre">tjp_task_template</span></code> variable with a local <strong>config.py</strong> file. See
<a class="reference external" href="../configure.html">configuring stalker</a></p>
</div>
<p>Although the values are not very important after TaskJuggler schedules a
task, the <a class="reference internal" href="#stalker.models.task.Task.start" title="stalker.models.task.Task.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a> and <a class="reference internal" href="#stalker.models.task.Task.end" title="stalker.models.task.Task.end"><code class="xref py py-attr docutils literal"><span class="pre">end</span></code></a> values for a container
task is gathered from the child tasks. The start is equal to the earliest
start value of the children tasks, and the end is equal to the latest end
value of the children tasks. Of course, these values are going to be
ignored by TaskJuggler, but for interactive gantt charts these are good toy
attributes to play with.</p>
<p>Stalker will check if there will be a cycle if one wants to parent a Task
to a child Task of its own or the dependency relation creates a cycle.</p>
<p>In Gantt Charts the <code class="docutils literal"><span class="pre">computed_start</span></code>, <code class="docutils literal"><span class="pre">computed_end</span></code> and
<code class="docutils literal"><span class="pre">computed_resources</span></code> attributes will be used if the task
<a class="reference internal" href="#stalker.models.task.Task.is_scheduled" title="stalker.models.task.Task.is_scheduled"><code class="xref py py-attr docutils literal"><span class="pre">is_scheduled</span></code></a>.</p>
<p><strong>Task Responsible</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.2.0: </span>Task Responsible</p>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.2.5: </span>Multiple Responsible Per Task</p>
</div>
</div>
<p>Tasks have a <strong>responsible</strong> which is a list of <a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a> instances
who are responsible of the assigned task and all the hierarchy under it.</p>
<p>If a task doesn&#8217;t have any responsible, it will start looking to its
parent tasks and will return the responsible of its parent and it will be
an empty list if non of its parents has a responsible.</p>
<p>You can create complex responsibility chains for different branches of
Tasks.</p>
<p><strong>Percent Complete Calculation</strong> .. versionadded:: 0.2.0</p>
<p>Tasks can calculate how much it is completed based on the
<a class="reference internal" href="#stalker.models.task.Task.schedule_seconds" title="stalker.models.task.Task.schedule_seconds"><code class="xref py py-attr docutils literal"><span class="pre">schedule_seconds</span></code></a> and <a class="reference internal" href="#stalker.models.task.Task.total_logged_seconds" title="stalker.models.task.Task.total_logged_seconds"><code class="xref py py-attr docutils literal"><span class="pre">total_logged_seconds</span></code></a> attributes.
For a parent task, the calculation is based on the total
<a class="reference internal" href="#stalker.models.task.Task.schedule_seconds" title="stalker.models.task.Task.schedule_seconds"><code class="xref py py-attr docutils literal"><span class="pre">schedule_seconds</span></code></a> and <a class="reference internal" href="#stalker.models.task.Task.total_logged_seconds" title="stalker.models.task.Task.total_logged_seconds"><code class="xref py py-attr docutils literal"><span class="pre">total_logged_seconds</span></code></a> attributes of
their children. Even tough, the percent_complete attribute of a task is
100% the task may not be considered as completed, because it may not be
reviewed and approved by the responsible yet.</p>
<p><strong>Task Review Workflow</strong></p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.2.5: </span>Task Review Workflow</p>
</div>
<p>Starting with Stalker v0.2.5 tasks are reviewed by their responsible users.
The reviews done by responsible users will set the task status according to
the supplied reviews. Please see the <a class="reference internal" href="stalker.models.review.Review.html#stalker.models.review.Review" title="stalker.models.review.Review"><code class="xref py py-class docutils literal"><span class="pre">Review</span></code></a> class documentation
for more details.</p>
<p><strong>Task Status Workflow</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.2.5: </span>Task Status Workflow</p>
</div>
</div>
<p>Task statuses now follow a workflow called &#8220;Task Status Workflow&#8221;.</p>
<p>The &#8220;Task Status Workflow&#8221; defines the different statuses that a Task will
have along its normal life cycle. Container and leaf tasks will have
different workflow using nearly the same set of statuses (container tasks
have only 4 statuses where as leaf tasks have 9).</p>
<p>The following diagram shows the status workflow for leaf tasks:</p>
<a class="reference internal image-reference" href="../_images/Task_Status_Workflow.png"><img alt="../_images/Task_Status_Workflow.png" class="align-center" src="../_images/Task_Status_Workflow.png" style="width: 637px; height: 611px;" /></a>
<p>The workflow defines the following statuses at described situations:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td colspan="2">LEAF TASK STATUS WORKFLOW</td>
</tr>
<tr class="row-even"><td>Status Name</td>
<td>Description</td>
</tr>
<tr class="row-odd"><td>Waiting For
Dependency (WFD)</td>
<td>If a task has uncompleted dependencies then it
will have its status to set to WFD. A WFD Task can
not have a TimeLog or a review request can not be
made for it.</td>
</tr>
<tr class="row-even"><td>Ready To Start
(RTS)</td>
<td>A task is set to RTS when there are no
dependencies or all of its dependencies are
completed, so there is nothing preventing it to be
started. An RTS Task can have new TimeLogs. A
review can not be requested at this stage cause no
work is done yet.</td>
</tr>
<tr class="row-odd"><td>Work In Progress
(WIP)</td>
<td>A task is set to WIP when a TimeLog has been
created for that task. A WIP task can have new
TimeLogs and a review can be requested for that
task.</td>
</tr>
<tr class="row-even"><td>Pending Review
(PREV)</td>
<td>A task is set to PREV when a new set of Review
instances created for it by using the
<a class="reference internal" href="#stalker.models.task.Task.request_review" title="stalker.models.task.Task.request_review"><code class="xref py py-meth docutils literal"><span class="pre">Task.request_review()</span></code></a> method. And it is
possible to request a review only for a task with
status WIP. A PREV task can not have new TimeLogs
nor a new request can be made because it is in
already in review.</td>
</tr>
<tr class="row-odd"><td>Has Revision
(HREV)</td>
<td>A task is set to HREV when one of its Reviews
completed by requesting a review by using the
<code class="xref py py-meth docutils literal"><span class="pre">Review.request_review()</span></code> method. A HREV Task
can have new TimeLogs, and it will be converted to
a WIP or DREV depending to its dependency task
statuses.</td>
</tr>
<tr class="row-even"><td>Dependency Has
Revision (DREV)</td>
<td>If the dependent task of a WIP, PREV, HREV, DREV
or CMPL task has a revision then the statuses of
the tasks are set to DREV which means both of the
dependee and the dependent tasks can work at the
same time. For a DREV task a review request can
not be made until it is set to WIP again by
setting the depending task to CMPL again.</td>
</tr>
<tr class="row-odd"><td>On Hold (OH)</td>
<td>A task is set to OH when the resource needs to
work for another task, and the <a class="reference internal" href="#stalker.models.task.Task.hold" title="stalker.models.task.Task.hold"><code class="xref py py-meth docutils literal"><span class="pre">Task.hold()</span></code></a>
is called. An OH Task can be resumed by calling
<a class="reference internal" href="#stalker.models.task.Task.resume" title="stalker.models.task.Task.resume"><code class="xref py py-meth docutils literal"><span class="pre">Task.resume()</span></code></a> method and depending to its
<a class="reference internal" href="#stalker.models.task.Task.time_logs" title="stalker.models.task.Task.time_logs"><code class="xref py py-attr docutils literal"><span class="pre">Task.time_logs</span></code></a> attribute it will have its
status set to RTS or WIP.</td>
</tr>
<tr class="row-even"><td>Stopped (STOP)</td>
<td><p class="first">A task is set to STOP when no more work needs to
done for that task and it will not be used
anymore. Call <a class="reference internal" href="#stalker.models.task.Task.stop" title="stalker.models.task.Task.stop"><code class="xref py py-meth docutils literal"><span class="pre">Task.stop()</span></code></a> method to do it
properly. Only applicable to WIP tasks.</p>
<p>The schedule values of the task will be capped to
current time spent on it, so Task Juggler will not
reserve any more resources for it.</p>
<p class="last">Also STOP tasks are treated as if they are dead.</p>
</td>
</tr>
<tr class="row-odd"><td>Completed (CMPL)</td>
<td>A task is set to CMPL when all of the Reviews are
completed by approving the task. It is not
possible to create any new TimeLogs and no new
review can be requested for a CMPL Task.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Container &#8220;Task Status Workflow&#8221; defines a set of statuses where the
container task status will only change according to its children task
statuses:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td colspan="2">CONTAINER TASK STATUS WORKFLOW</td>
</tr>
<tr class="row-even"><td>Status Name</td>
<td>Description</td>
</tr>
<tr class="row-odd"><td>Waiting For
Dependency (WFD)</td>
<td>If all of the child tasks are in WFD status then
the container task is also WFD.</td>
</tr>
<tr class="row-even"><td>Ready To Start
(RTS)</td>
<td>A container task is set to RTS when children tasks
have statuses of only WFD and RTS.</td>
</tr>
<tr class="row-odd"><td>Work In Progress
(WIP)</td>
<td>A container task is set to WIP when one of its
children tasks have any of the statuses of RTS,
WIP, PREV, HREV, DREV or CMPL.</td>
</tr>
<tr class="row-even"><td>Completed (CMPL)</td>
<td>A container task is set to CMPL when all of its
children tasks are CMPL.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Even though, users are encouraged to use the actions (like
<a class="reference internal" href="#stalker.models.task.Task.create_time_log" title="stalker.models.task.Task.create_time_log"><code class="xref py py-meth docutils literal"><span class="pre">Task.create_time_log()</span></code></a>, <a class="reference internal" href="#stalker.models.task.Task.hold" title="stalker.models.task.Task.hold"><code class="xref py py-meth docutils literal"><span class="pre">Task.hold()</span></code></a>, <a class="reference internal" href="#stalker.models.task.Task.stop" title="stalker.models.task.Task.stop"><code class="xref py py-meth docutils literal"><span class="pre">Task.stop()</span></code></a>,
<a class="reference internal" href="#stalker.models.task.Task.resume" title="stalker.models.task.Task.resume"><code class="xref py py-meth docutils literal"><span class="pre">Task.resume()</span></code></a>, <a class="reference internal" href="#stalker.models.task.Task.request_revision" title="stalker.models.task.Task.request_revision"><code class="xref py py-meth docutils literal"><span class="pre">Task.request_revision()</span></code></a>,
<a class="reference internal" href="#stalker.models.task.Task.request_review" title="stalker.models.task.Task.request_review"><code class="xref py py-meth docutils literal"><span class="pre">Task.request_review()</span></code></a>, <code class="xref py py-meth docutils literal"><span class="pre">Task.approve()</span></code>) to update the task
statuses , setting the <a class="reference internal" href="#stalker.models.task.Task.status" title="stalker.models.task.Task.status"><code class="xref py py-attr docutils literal"><span class="pre">Task.status</span></code></a> will also update the dependent
tasks or will check the new status against dependencies or the current
status of the task.</p>
<p>Thus in some situations setting the <a class="reference internal" href="#stalker.models.task.Task.status" title="stalker.models.task.Task.status"><code class="xref py py-attr docutils literal"><span class="pre">Task.status</span></code></a> will not change
the status of the task. For example, setting the task status to WFD when
there are no dependencies will not update the task status to WFD,
also updating a PREV task status to STOP or HOLD or RTS is not possible.
And it is not possible to set a task to WIP if there are no TimeLogs
entered for that task.</p>
<p>So the task will strictly follow the Task Status Workflow diagram above.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p><strong>Dependency Relation in Task Status Workflow</strong></p>
<p class="last">Because the Task Status Workflow heavily effected by the dependent task
statuses, and the main reason of having dependency relation is to let
TaskJuggler to schedule the tasks correctly, and any task status other
than WFD or RTS means that a TimeLog has been created for a task (which
means that you can not change the <a class="reference internal" href="#stalker.models.task.Task.computed_start" title="stalker.models.task.Task.computed_start"><code class="xref py py-attr docutils literal"><span class="pre">computed_start</span></code></a> anymore), it
is only allowed to change the dependencies of a WFD and RTS tasks.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p><strong>Resuming a STOP Task</strong></p>
<p class="last">Resuming a STOP Task will be treated as if a revision has been made to
that task, and all the statuses of the tasks depending to this
particular task will be updated accordingly.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p><strong>Initial Status of a Task</strong></p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.2.5.</span></p>
</div>
<p class="last">Because of the Task Status Workflow, supplying a status with the
<strong>status</strong> argument may not set the status of the Task to the desired
value. A Task starts with WFD status by default, and updated to RTS if
it doesn&#8217;t have any dependencies or all of the dependencies are STOP or
CMPL.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.2.5.2: </span>Task.path and Task.absolute_path properties</p>
<p>Task instances now have two new properties called <a class="reference internal" href="#stalker.models.task.Task.path" title="stalker.models.task.Task.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a> and
<a class="reference internal" href="#stalker.models.task.Task.absolute_path" title="stalker.models.task.Task.absolute_path"><code class="xref py py-attr docutils literal"><span class="pre">absolute_path</span></code></a>. The value of these attributes are the
rendered version of the related <a class="reference internal" href="stalker.models.template.FilenameTemplate.html#stalker.models.template.FilenameTemplate" title="stalker.models.template.FilenameTemplate"><code class="xref py py-class docutils literal"><span class="pre">FilenameTemplate</span></code></a> which
has its target_entity_type attribute set to &#8220;Task&#8221; (or &#8220;Asset&#8221;,
&#8220;Shot&#8221; or &#8220;Sequence&#8221; or anything matching to the derived class name,
so it can be used in <a class="reference internal" href="stalker.models.asset.Asset.html#stalker.models.asset.Asset" title="stalker.models.asset.Asset"><code class="xref py py-class docutils literal"><span class="pre">Asset</span></code></a>, <a class="reference internal" href="stalker.models.shot.Shot.html#stalker.models.shot.Shot" title="stalker.models.shot.Shot"><code class="xref py py-class docutils literal"><span class="pre">Shot</span></code></a> and
<code class="xref py py-class docutils literal"><span class="pre">Sequences</span></code> or anything that is derived from Task class) in
the <a class="reference internal" href="stalker.models.project.Project.html#stalker.models.project.Project" title="stalker.models.project.Project"><code class="xref py py-class docutils literal"><span class="pre">Project</span></code></a> that this task belongs to. This property has
been added to make it easier to write custom template codes for
Project <a class="reference internal" href="stalker.models.structure.Structure.html#stalker.models.structure.Structure" title="stalker.models.structure.Structure"><code class="xref py py-class docutils literal"><span class="pre">Structure</span></code></a>s.</p>
<p>The <a class="reference internal" href="#stalker.models.task.Task.path" title="stalker.models.task.Task.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a> attribute is a repository relative path, where as
the <a class="reference internal" href="#stalker.models.task.Task.absolute_path" title="stalker.models.task.Task.absolute_path"><code class="xref py py-attr docutils literal"><span class="pre">absolute_path</span></code></a> is the full path and includs the OS
dependent repository path.</p>
</div>
</div>
<p><strong>Arguments</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>project</strong> (<a class="reference internal" href="stalker.models.project.Project.html#stalker.models.project.Project" title="stalker.models.project.Project"><code class="xref py py-class docutils literal"><span class="pre">Project</span></code></a>) &#8211; A Task which doesn&#8217;t have a parent (a root task) should be
created with a <a class="reference internal" href="stalker.models.project.Project.html#stalker.models.project.Project" title="stalker.models.project.Project"><code class="xref py py-class docutils literal"><span class="pre">Project</span></code></a> instance. If it is skipped an no
<a class="reference internal" href="#stalker.models.task.Task.parent" title="stalker.models.task.Task.parent"><code class="xref py py-attr docutils literal"><span class="pre">parent</span></code></a> is given then Stalker will raise a RuntimeError. If both
the <code class="docutils literal"><span class="pre">project</span></code> and the <a class="reference internal" href="#stalker.models.task.Task.parent" title="stalker.models.task.Task.parent"><code class="xref py py-attr docutils literal"><span class="pre">parent</span></code></a> argument contains data and the
project of the Task instance given with parent argument is different than
the Project instance given with the <code class="docutils literal"><span class="pre">project</span></code> argument then a
RuntimeWarning will be raised and the project of the parent task will be
used.</li>
<li><strong>parent</strong> (<a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a>) &#8211; The parent Task or Project of this Task. Every Task in
Stalker should be related with a <a class="reference internal" href="stalker.models.project.Project.html#stalker.models.project.Project" title="stalker.models.project.Project"><code class="xref py py-class docutils literal"><span class="pre">Project</span></code></a> instance. So if no
parent task is desired, at least a Project instance should be passed as
the parent of the created Task or the Task will be an orphan task and
Stalker will raise a RuntimeError.</li>
<li><strong>depends</strong> ([<a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a>]) &#8211; A list of <a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a>s that this <a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> is
depending on. A Task can not depend to itself or any other Task which are
already depending to this one in anyway or a CircularDependency error
will be raised.</li>
<li><strong>resources</strong> ([<a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a>]) &#8211; The <a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a>s assigned to this <a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a>. A
<a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> without any resource can not be scheduled.</li>
<li><strong>responsible</strong> ([<a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a>]) &#8211; A list of <a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a> instances that is responsible
of this task.</li>
<li><strong>watchers</strong> ([<a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a>]) &#8211; A list of <a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a> those are added this Task
instance to their watchlist.</li>
<li><strong>start</strong> (<a class="reference external" href="http://docs.python.org/library/datetime.html#datetime.datetime" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">datetime.datetime</span></code></a>) &#8211; The start date and time of this task instance. It is only
used if the <a class="reference internal" href="#stalker.models.task.Task.schedule_constraint" title="stalker.models.task.Task.schedule_constraint"><code class="xref py py-attr docutils literal"><span class="pre">schedule_constraint</span></code></a> attribute is set to
<code class="xref py py-attr docutils literal"><span class="pre">CONSTRAIN_START</span></code> or <code class="xref py py-attr docutils literal"><span class="pre">CONSTRAIN_BOTH</span></code>. The default value
is <cite>datetime.datetime.now()</cite>.</li>
<li><strong>end</strong> (<a class="reference external" href="http://docs.python.org/library/datetime.html#datetime.datetime" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">datetime.datetime</span></code></a>) &#8211; The end date and time of this task instance. It is only used if
the <a class="reference internal" href="#stalker.models.task.Task.schedule_constraint" title="stalker.models.task.Task.schedule_constraint"><code class="xref py py-attr docutils literal"><span class="pre">schedule_constraint</span></code></a> attribute is set to
<code class="xref py py-attr docutils literal"><span class="pre">CONSTRAIN_END</span></code> or <code class="xref py py-attr docutils literal"><span class="pre">CONSTRAIN_BOTH</span></code>. The default value is
<cite>datetime.datetime.now()</cite>.</li>
<li><strong>schedule_timing</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; The value of the schedule timing.</li>
<li><strong>schedule_unit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; The unit value of the schedule timing. Should be
one of &#8216;min&#8217;, &#8216;h&#8217;, &#8216;d&#8217;, &#8216;w&#8217;, &#8216;m&#8217;, &#8216;y&#8217;.</li>
<li><strong>schedule_constraint</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; The schedule constraint. It is the index
of the schedule constraints value in
<code class="xref py py-class docutils literal"><span class="pre">stalker.config.Config.task_schedule_constraints</span></code>.</li>
<li><strong>bid_timing</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; The initial bid for this Task. It can be used in
measuring how accurate the initial guess was. It will be compared against
the total amount of effort spend doing this task. Can be set to None,
which will be set to the schedule_timing_day argument value if there is
one or 0.</li>
<li><strong>bid_unit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; The unit of the bid value for this Task. Should be one
of the &#8216;min&#8217;, &#8216;h&#8217;, &#8216;d&#8217;, &#8216;w&#8217;, &#8216;m&#8217;, &#8216;y&#8217;.</li>
<li><strong>is_milestone</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; A bool (True or False) value showing if this task
is a milestone which doesn&#8217;t need any resource and effort.</li>
<li><strong>priority</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; <p>It is a number between 0 to 1000 which defines the
priority of the <a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a>. The higher the value the higher its
priority. The default value is 500. Mainly used by TaskJuggler.</p>
<p>Higher priority tasks will be scheduled to an early date or at least will
tried to be scheduled to an early date then a lower priority task (a task
that is using the same resources).</p>
<p>In complex projects, a task with a lower priority task may steal
resources from a higher priority task, this is due to the internals of
TaskJuggler, it tries to increase the resource utilization by letting the
lower priority task to be completed earlier than the higher priority
task. This is done in that way if the lower priority task is dependent of
more important tasks (tasks in critical path or tasks with critical
resources). Read TaskJuggler documentation for more information on how
TaskJuggler schedules tasks.</p>
</li>
<li><strong>allocation_strategy</strong> &#8211; Defines the allocation strategy for resources
of a task with alternative resources. Should be one of [&#8216;minallocated&#8217;,
&#8216;maxloaded&#8217;, &#8216;minloaded&#8217;, &#8216;order&#8217;, &#8216;random&#8217;] and the default value is
&#8216;minallocated&#8217;. For more information read the <a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> class
documetation.</li>
<li><strong>persistent_allocation</strong> &#8211; Specifies that once a resource is picked from
the list of alternatives this resource is used for the whole task. The
default value is True. For more information read the <a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> class
documentation.</li>
<li><strong>good</strong> &#8211; It is possible to attach a good to this Task to be able to
filter and group them later on.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="stalker.models.task.Task.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>project=None</em>, <em>parent=None</em>, <em>depends=None</em>, <em>resources=None</em>, <em>alternative_resources=None</em>, <em>responsible=None</em>, <em>watchers=None</em>, <em>start=None</em>, <em>end=None</em>, <em>schedule_timing=1.0</em>, <em>schedule_unit='h'</em>, <em>schedule_model=None</em>, <em>schedule_constraint=0</em>, <em>bid_timing=None</em>, <em>bid_unit=None</em>, <em>is_milestone=False</em>, <em>priority=500</em>, <em>allocation_strategy='minallocated'</em>, <em>persistent_allocation=True</em>, <em>good=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.__init__" title="stalker.models.task.Task.__init__"><code class="xref py py-obj docutils literal"><span class="pre">__init__</span></code></a>([project,&nbsp;parent,&nbsp;depends,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.create_time_log" title="stalker.models.task.Task.create_time_log"><code class="xref py py-obj docutils literal"><span class="pre">create_time_log</span></code></a>(resource,&nbsp;start,&nbsp;end)</td>
<td>A helper method to create TimeLogs, this will ease creating TimeLog instances for task.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.hold" title="stalker.models.task.Task.hold"><code class="xref py py-obj docutils literal"><span class="pre">hold</span></code></a>()</td>
<td>Pauses the execution of this task by setting its status to OH.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.request_review" title="stalker.models.task.Task.request_review"><code class="xref py py-obj docutils literal"><span class="pre">request_review</span></code></a>()</td>
<td>Creates and returns Review instances for each of the responsible of this task and sets the task status to PREV.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.request_revision" title="stalker.models.task.Task.request_revision"><code class="xref py py-obj docutils literal"><span class="pre">request_revision</span></code></a>([reviewer,&nbsp;description,&nbsp;...])</td>
<td>Requests revision.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.resume" title="stalker.models.task.Task.resume"><code class="xref py py-obj docutils literal"><span class="pre">resume</span></code></a>()</td>
<td>Resumes the execution of this task by setting its status to RTS or WIP depending to its time_logs attribute, so if it has TimeLogs then it will resume as WIP and if it doesn&#8217;t then it will resume as RTS.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.review_set" title="stalker.models.task.Task.review_set"><code class="xref py py-obj docutils literal"><span class="pre">review_set</span></code></a>([review_number])</td>
<td>returns the reviews with the given review_number, if review_number</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.stop" title="stalker.models.task.Task.stop"><code class="xref py py-obj docutils literal"><span class="pre">stop</span></code></a>()</td>
<td>Stops this task.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.update_parent_statuses" title="stalker.models.task.Task.update_parent_statuses"><code class="xref py py-obj docutils literal"><span class="pre">update_parent_statuses</span></code></a>()</td>
<td>updates the parent statuses of this task if any</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.update_schedule_info" title="stalker.models.task.Task.update_schedule_info"><code class="xref py py-obj docutils literal"><span class="pre">update_schedule_info</span></code></a>()</td>
<td>updates the total_logged_seconds and schedule_seconds attributes by</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.update_status_with_children_statuses" title="stalker.models.task.Task.update_status_with_children_statuses"><code class="xref py py-obj docutils literal"><span class="pre">update_status_with_children_statuses</span></code></a>()</td>
<td>updates the task status according to its children statuses</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.update_status_with_dependent_statuses" title="stalker.models.task.Task.update_status_with_dependent_statuses"><code class="xref py py-obj docutils literal"><span class="pre">update_status_with_dependent_statuses</span></code></a>([removing])</td>
<td>updates the status by looking at the dependent tasks</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.walk_dependencies" title="stalker.models.task.Task.walk_dependencies"><code class="xref py py-obj docutils literal"><span class="pre">walk_dependencies</span></code></a>([method])</td>
<td>Walks the dependencies of this task</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.absolute_path" title="stalker.models.task.Task.absolute_path"><code class="xref py py-obj docutils literal"><span class="pre">absolute_path</span></code></a></td>
<td>the absolute_path attribute</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.computed_duration" title="stalker.models.task.Task.computed_duration"><code class="xref py py-obj docutils literal"><span class="pre">computed_duration</span></code></a></td>
<td>returns the computed_duration as the difference of computed_start</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.computed_total_seconds" title="stalker.models.task.Task.computed_total_seconds"><code class="xref py py-obj docutils literal"><span class="pre">computed_total_seconds</span></code></a></td>
<td>returns the duration as seconds</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.is_container" title="stalker.models.task.Task.is_container"><code class="xref py py-obj docutils literal"><span class="pre">is_container</span></code></a></td>
<td>Returns True if the Task has children Tasks</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.is_leaf" title="stalker.models.task.Task.is_leaf"><code class="xref py py-obj docutils literal"><span class="pre">is_leaf</span></code></a></td>
<td>Returns True if the Task has no children Tasks</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.is_root" title="stalker.models.task.Task.is_root"><code class="xref py py-obj docutils literal"><span class="pre">is_root</span></code></a></td>
<td>Returns True if the Task has no parent</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.is_scheduled" title="stalker.models.task.Task.is_scheduled"><code class="xref py py-obj docutils literal"><span class="pre">is_scheduled</span></code></a></td>
<td>A predicate which returns True if this task has both a</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.level" title="stalker.models.task.Task.level"><code class="xref py py-obj docutils literal"><span class="pre">level</span></code></a></td>
<td>Returns the level of this task.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.nice_name" title="stalker.models.task.Task.nice_name"><code class="xref py py-obj docutils literal"><span class="pre">nice_name</span></code></a></td>
<td>Nice name of this object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.open_tickets" title="stalker.models.task.Task.open_tickets"><code class="xref py py-obj docutils literal"><span class="pre">open_tickets</span></code></a></td>
<td>returns the open tickets referencing this task in their links</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.parents" title="stalker.models.task.Task.parents"><code class="xref py py-obj docutils literal"><span class="pre">parents</span></code></a></td>
<td>Returns all of the parents of this mixed in class starting from the</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.path" title="stalker.models.task.Task.path"><code class="xref py py-obj docutils literal"><span class="pre">path</span></code></a></td>
<td>The path attribute will generate a path suitable for placing the files under it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.percent_complete" title="stalker.models.task.Task.percent_complete"><code class="xref py py-obj docutils literal"><span class="pre">percent_complete</span></code></a></td>
<td>returns the percent_complete based on the total_logged_seconds and</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.plural_class_name" title="stalker.models.task.Task.plural_class_name"><code class="xref py py-obj docutils literal"><span class="pre">plural_class_name</span></code></a></td>
<td>the plural name of this class</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.remaining_seconds" title="stalker.models.task.Task.remaining_seconds"><code class="xref py py-obj docutils literal"><span class="pre">remaining_seconds</span></code></a></td>
<td>returns the remaining amount of efforts, length or duration left</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.tickets" title="stalker.models.task.Task.tickets"><code class="xref py py-obj docutils literal"><span class="pre">tickets</span></code></a></td>
<td>returns the tickets referencing this task in their links attribute</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.tjp_abs_id" title="stalker.models.task.Task.tjp_abs_id"><code class="xref py py-obj docutils literal"><span class="pre">tjp_abs_id</span></code></a></td>
<td>returns the calculated absolute id of this task</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.tjp_id" title="stalker.models.task.Task.tjp_id"><code class="xref py py-obj docutils literal"><span class="pre">tjp_id</span></code></a></td>
<td>returns TaskJuggler compatible id</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#stalker.models.task.Task.to_tjp" title="stalker.models.task.Task.to_tjp"><code class="xref py py-obj docutils literal"><span class="pre">to_tjp</span></code></a></td>
<td>TaskJuggler representation of this task</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stalker.models.task.Task.total_seconds" title="stalker.models.task.Task.total_seconds"><code class="xref py py-obj docutils literal"><span class="pre">total_seconds</span></code></a></td>
<td>returns the duration as seconds</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="stalker.models.task.Task.absolute_path">
<code class="descname">absolute_path</code><a class="headerlink" href="#stalker.models.task.Task.absolute_path" title="Permalink to this definition">¶</a></dt>
<dd><p>the absolute_path attribute</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.allocation_strategy">
<code class="descname">allocation_strategy</code><a class="headerlink" href="#stalker.models.task.Task.allocation_strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Please read <a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> class documentation for details.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.alternative_resources">
<code class="descname">alternative_resources</code><a class="headerlink" href="#stalker.models.task.Task.alternative_resources" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of <a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a>s assigned to this Task as an alternative resource.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.bid_timing">
<code class="descname">bid_timing</code><a class="headerlink" href="#stalker.models.task.Task.bid_timing" title="Permalink to this definition">¶</a></dt>
<dd><p>The value of the initial bid of this Task. It is an integer or
a float.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.bid_unit">
<code class="descname">bid_unit</code><a class="headerlink" href="#stalker.models.task.Task.bid_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>The unit of the initial bid of this Task. It is a string value.
And should be one of &#8216;min&#8217;, &#8216;h&#8217;, &#8216;d&#8217;, &#8216;w&#8217;, &#8216;m&#8217;, &#8216;y&#8217;.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.children">
<code class="descname">children</code><a class="headerlink" href="#stalker.models.task.Task.children" title="Permalink to this definition">¶</a></dt>
<dd><p>Other <code class="xref py py-class docutils literal"><span class="pre">Budget</span></code> instances which are the children of this
one. This attribute along with the <a class="reference internal" href="#stalker.models.task.Task.parent" title="stalker.models.task.Task.parent"><code class="xref py py-attr docutils literal"><span class="pre">parent</span></code></a> attribute is used in
creating a DAG hierarchy of tasks.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.computed_duration">
<code class="descname">computed_duration</code><a class="headerlink" href="#stalker.models.task.Task.computed_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the computed_duration as the difference of computed_start
and computed_end if there are computed_start and computed_end otherwise
returns None</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.computed_end">
<code class="descname">computed_end</code><a class="headerlink" href="#stalker.models.task.Task.computed_end" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference external" href="http://docs.python.org/library/datetime.html#datetime.datetime" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">datetime</span></code></a> instance showing the end value
computed by <strong>TaskJuggler</strong>. It is None if this task is not scheduled
yet.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.computed_resources">
<code class="descname">computed_resources</code><a class="headerlink" href="#stalker.models.task.Task.computed_resources" title="Permalink to this definition">¶</a></dt>
<dd><p>getter for the _computed_resources attribute</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.computed_start">
<code class="descname">computed_start</code><a class="headerlink" href="#stalker.models.task.Task.computed_start" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference external" href="http://docs.python.org/library/datetime.html#datetime.datetime" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">datetime</span></code></a> instance showing the start value
computed by <strong>TaskJuggler</strong>. It is None if this task is not scheduled
yet.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.computed_total_seconds">
<code class="descname">computed_total_seconds</code><a class="headerlink" href="#stalker.models.task.Task.computed_total_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the duration as seconds</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.create_time_log">
<code class="descname">create_time_log</code><span class="sig-paren">(</span><em>resource</em>, <em>start</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.create_time_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper method to create TimeLogs, this will ease creating TimeLog
instances for task.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.created_by">
<code class="descname">created_by</code><a class="headerlink" href="#stalker.models.task.Task.created_by" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a> who has created this object.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.created_by_id">
<code class="descname">created_by_id</code><a class="headerlink" href="#stalker.models.task.Task.created_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the <a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a> who has created this entity.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.date_created">
<code class="descname">date_created</code><a class="headerlink" href="#stalker.models.task.Task.date_created" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference external" href="http://docs.python.org/library/datetime.html#datetime.datetime" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">datetime.datetime</span></code></a> instance showing the creation date
and time of this object.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.date_updated">
<code class="descname">date_updated</code><a class="headerlink" href="#stalker.models.task.Task.date_updated" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference external" href="http://docs.python.org/library/datetime.html#datetime.datetime" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">datetime.datetime</span></code></a> instance showing the update date
and time of this object.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.description">
<code class="descname">description</code><a class="headerlink" href="#stalker.models.task.Task.description" title="Permalink to this definition">¶</a></dt>
<dd><p>Description of this object.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.duration">
<code class="descname">duration</code><a class="headerlink" href="#stalker.models.task.Task.duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Duration of the entity.</p>
<p>It is a datetime.timedelta instance. Showing the difference of
the <a class="reference internal" href="#stalker.models.task.Task.start" title="stalker.models.task.Task.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a> and the <a class="reference internal" href="#stalker.models.task.Task.end" title="stalker.models.task.Task.end"><code class="xref py py-attr docutils literal"><span class="pre">end</span></code></a>. If edited it changes
the <a class="reference internal" href="#stalker.models.task.Task.end" title="stalker.models.task.Task.end"><code class="xref py py-attr docutils literal"><span class="pre">end</span></code></a> attribute value.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.end">
<code class="descname">end</code><a class="headerlink" href="#stalker.models.task.Task.end" title="Permalink to this definition">¶</a></dt>
<dd><p>overridden end getter</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.generic_data">
<code class="descname">generic_data</code><a class="headerlink" href="#stalker.models.task.Task.generic_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute can hold any kind of data which exists in SOM.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.generic_text">
<code class="descname">generic_text</code><a class="headerlink" href="#stalker.models.task.Task.generic_text" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute can hold any text.</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.hold">
<code class="descname">hold</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.hold" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauses the execution of this task by setting its status to OH. Only
applicable to RTS and WIP tasks, any task with other statuses will
raise a ValueError.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.is_container">
<code class="descname">is_container</code><a class="headerlink" href="#stalker.models.task.Task.is_container" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the Task has children Tasks</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.is_leaf">
<code class="descname">is_leaf</code><a class="headerlink" href="#stalker.models.task.Task.is_leaf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the Task has no children Tasks</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.is_milestone">
<code class="descname">is_milestone</code><a class="headerlink" href="#stalker.models.task.Task.is_milestone" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies if this Task is a milestone.</p>
<p>Milestones doesn&#8217;t need any duration, any effort and any resources. It
is used to create meaningful dependencies between the critical stages
of the project.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.is_root">
<code class="descname">is_root</code><a class="headerlink" href="#stalker.models.task.Task.is_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the Task has no parent</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.is_scheduled">
<code class="descname">is_scheduled</code><a class="headerlink" href="#stalker.models.task.Task.is_scheduled" title="Permalink to this definition">¶</a></dt>
<dd><p>A predicate which returns True if this task has both a
computed_start and computed_end values</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.least_meaningful_time_unit">
<code class="descname">least_meaningful_time_unit</code><span class="sig-paren">(</span><em>seconds</em>, <em>as_work_time=True</em><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.least_meaningful_time_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the least meaningful timing unit that corresponds to the
given seconds. So if:</p>
<blockquote>
<div><dl class="docutils">
<dt>as_work_time == True</dt>
<dd>seconds % (1 years work time as seconds) == 0 &#8211;&gt; &#8216;y&#8217; else:
seconds % (1 month work time as seconds) == 0 &#8211;&gt; &#8216;m&#8217; else:
seconds % (1 week work time as seconds) == 0 &#8211;&gt; &#8216;w&#8217; else:
seconds % (1 day work time as seconds) == 0 &#8211;&gt; &#8216;d&#8217; else:
seconds % (1 hour work time as seconds) == 0 &#8211;&gt; &#8216;h&#8217; else:
seconds % (1 minutes work time as seconds) == 0 &#8211;&gt; &#8216;min&#8217; else:
raise RuntimeError</dd>
<dt>as_work_time == False</dt>
<dd>seconds % (1 years as seconds) == 0 &#8211;&gt; &#8216;y&#8217; else:
seconds % (1 month as seconds) == 0 &#8211;&gt; &#8216;m&#8217; else:
seconds % (1 week as seconds) == 0 &#8211;&gt; &#8216;w&#8217; else:
seconds % (1 day as seconds) == 0 &#8211;&gt; &#8216;d&#8217; else:
seconds % (1 hour as seconds) == 0 &#8211;&gt; &#8216;h&#8217; else:
seconds % (1 minutes as seconds) == 0 &#8211;&gt; &#8216;min&#8217; else:
raise RuntimeError</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>seconds</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; An integer showing the total seconds to be
converted.</li>
<li><strong>as_work_time</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; Should the input be considered as work time
or calendar time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Returns int, string:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">Returns one integer and one string, showing the
timing value and the unit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.level">
<code class="descname">level</code><a class="headerlink" href="#stalker.models.task.Task.level" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the level of this task. It is a temporary property and will
be useless when Stalker has its own implementation of a proper Gantt
Chart. Write now it is used by the jQueryGantt.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.name">
<code class="descname">name</code><a class="headerlink" href="#stalker.models.task.Task.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of this object</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.nice_name">
<code class="descname">nice_name</code><a class="headerlink" href="#stalker.models.task.Task.nice_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Nice name of this object.</p>
<p>It has the same value with the name (contextually) but with a different
format like, all the white spaces replaced by underscores (&#8220;_&#8221;), all
the CamelCase form will be expanded by underscore (_) characters and
it is always lower case.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.notes">
<code class="descname">notes</code><a class="headerlink" href="#stalker.models.task.Task.notes" title="Permalink to this definition">¶</a></dt>
<dd><p>All the <code class="xref py py-class docutils literal"><span class="pre">Notes</span></code>s attached to this entity.</p>
<p>It is a list of <a class="reference internal" href="stalker.models.note.Note.html#stalker.models.note.Note" title="stalker.models.note.Note"><code class="xref py py-class docutils literal"><span class="pre">Note</span></code></a> instances or an
empty list, setting it to None will raise a TypeError.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.open_tickets">
<code class="descname">open_tickets</code><a class="headerlink" href="#stalker.models.task.Task.open_tickets" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the open tickets referencing this task in their links
attribute</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.parent">
<code class="descname">parent</code><a class="headerlink" href="#stalker.models.task.Task.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> instance which is the parent of this Task.
In Stalker it is possible to create a hierarchy of Task.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.parents">
<code class="descname">parents</code><a class="headerlink" href="#stalker.models.task.Task.parents" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all of the parents of this mixed in class starting from the
root</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.path">
<code class="descname">path</code><a class="headerlink" href="#stalker.models.task.Task.path" title="Permalink to this definition">¶</a></dt>
<dd><p>The path attribute will generate a path suitable for placing the
files under it. It will use the <a class="reference internal" href="stalker.models.template.FilenameTemplate.html#stalker.models.template.FilenameTemplate" title="stalker.models.template.FilenameTemplate"><code class="xref py py-class docutils literal"><span class="pre">FilenameTemplate</span></code></a> class
related to the <a class="reference internal" href="stalker.models.project.Project.html#stalker.models.project.Project" title="stalker.models.project.Project"><code class="xref py py-class docutils literal"><span class="pre">Project</span></code></a> <a class="reference internal" href="stalker.models.structure.Structure.html#stalker.models.structure.Structure" title="stalker.models.structure.Structure"><code class="xref py py-class docutils literal"><span class="pre">Structure</span></code></a> with the
<code class="docutils literal"><span class="pre">target_entity_type</span></code> is set to the type of this instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.percent_complete">
<code class="descname">percent_complete</code><a class="headerlink" href="#stalker.models.task.Task.percent_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the percent_complete based on the total_logged_seconds and
schedule_seconds of the task. Container tasks will use info from their
children</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.persistent_allocation">
<code class="descname">persistent_allocation</code><a class="headerlink" href="#stalker.models.task.Task.persistent_allocation" title="Permalink to this definition">¶</a></dt>
<dd><p>Please read <a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> class documentation for details.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.plural_class_name">
<code class="descname">plural_class_name</code><a class="headerlink" href="#stalker.models.task.Task.plural_class_name" title="Permalink to this definition">¶</a></dt>
<dd><p>the plural name of this class</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.priority">
<code class="descname">priority</code><a class="headerlink" href="#stalker.models.task.Task.priority" title="Permalink to this definition">¶</a></dt>
<dd><p>An integer number between 0 and 1000 used by TaskJuggler to
determine the priority of this Task. The default value is 500.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.project">
<code class="descname">project</code><a class="headerlink" href="#stalker.models.task.Task.project" title="Permalink to this definition">¶</a></dt>
<dd><p>The owner Project of this task.</p>
<p>It is a read-only attribute. It is not possible to change the owner
Project of a Task it is defined when the Task is created.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.project_id">
<code class="descname">project_id</code><a class="headerlink" href="#stalker.models.task.Task.project_id" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the owner <a class="reference internal" href="stalker.models.project.Project.html#stalker.models.project.Project" title="stalker.models.project.Project"><code class="xref py py-class docutils literal"><span class="pre">Project</span></code></a> of this Task. This
attribute is mainly used by <strong>SQLAlchemy</strong> to map a <a class="reference internal" href="stalker.models.project.Project.html#stalker.models.project.Project" title="stalker.models.project.Project"><code class="xref py py-class docutils literal"><span class="pre">Project</span></code></a>
instance to a Task.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.references">
<code class="descname">references</code><a class="headerlink" href="#stalker.models.task.Task.references" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of <a class="reference internal" href="stalker.models.link.Link.html#stalker.models.link.Link" title="stalker.models.link.Link"><code class="xref py py-class docutils literal"><span class="pre">Link</span></code></a> instances given as a reference for
this entity.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.remaining_seconds">
<code class="descname">remaining_seconds</code><a class="headerlink" href="#stalker.models.task.Task.remaining_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the remaining amount of efforts, length or duration left
in this Task as seconds.</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.request_review">
<code class="descname">request_review</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.request_review" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and returns Review instances for each of the responsible of
this task and sets the task status to PREV.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.2.0: </span>Request review will not cap the timing of this task anymore.</p>
</div>
<p>Only applicable to leaf tasks.</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.request_revision">
<code class="descname">request_revision</code><span class="sig-paren">(</span><em>reviewer=None</em>, <em>description=''</em>, <em>schedule_timing=1</em>, <em>schedule_unit='h'</em><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.request_revision" title="Permalink to this definition">¶</a></dt>
<dd><p>Requests revision.</p>
<p>Applicable to PREV or CMPL leaf tasks. This method will expand the
schedule timings of the task according to the supplied arguments.</p>
<p>When request_revision is called on a PREV task, the other NEW Review
instances (those created when request_review on a WIP task is called
and still waiting a review) will be deleted.</p>
<p>This method at the end will return a new Review instance with correct
attributes (reviewer, description, schedule_timing, schedule_unit and
review_number attributes).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reviewer</strong> (class:<cite>.User</cite>) &#8211; This is the user that requested the revision. He/she
doesn&#8217;t need to be the responsible, anybody that has a Permission to
create a Review instance can request a revision.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.resources">
<code class="descname">resources</code><a class="headerlink" href="#stalker.models.task.Task.resources" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of <a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a>s assigned to this Task.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.responsible">
<code class="descname">responsible</code><a class="headerlink" href="#stalker.models.task.Task.responsible" title="Permalink to this definition">¶</a></dt>
<dd><p>The responsible of this task.</p>
<p>This attribute will return the responsible of this task which is a
list of <a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a> instances. If there is no responsible set
for this task, then it will try to find a responsible in its
parents.</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.resume">
<code class="descname">resume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Resumes the execution of this task by setting its status to RTS or
WIP depending to its time_logs attribute, so if it has TimeLogs then it
will resume as WIP and if it doesn&#8217;t then it will resume as RTS. Only
applicable to Tasks with status OH.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.review_number">
<code class="descname">review_number</code><a class="headerlink" href="#stalker.models.task.Task.review_number" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the _review_number attribute value</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.review_set">
<code class="descname">review_set</code><span class="sig-paren">(</span><em>review_number=None</em><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.review_set" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the reviews with the given review_number, if review_number
is skipped it will return the latest set of reviews</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.reviews">
<code class="descname">reviews</code><a class="headerlink" href="#stalker.models.task.Task.reviews" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of <a class="reference internal" href="stalker.models.review.Review.html#stalker.models.review.Review" title="stalker.models.review.Review"><code class="xref py py-class docutils literal"><span class="pre">Review</span></code></a> holding the details about the reviews
created for this task.</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.round_time">
<code class="descname">round_time</code><span class="sig-paren">(</span><em>dt</em><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.round_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Round the given datetime object to the defaults.timing_resolution.</p>
<p>Uses <code class="xref py py-class docutils literal"><span class="pre">stalker.defaults.timing_resolution</span></code> as the closest number
of seconds to round to.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dt</strong> (<a class="reference external" href="http://docs.python.org/library/datetime.html#datetime.datetime" title="(in Python v2.7)"><em>datetime.datetime</em></a>) &#8211; datetime.datetime object, defaults to now.</td>
</tr>
</tbody>
</table>
<p>Based on Thierry Husson&#8217;s answer in <a class="reference internal" href="#stackoverflow">Stackoverflow</a></p>
<p><span class="target" id="stackoverflow">Stackoverflow</span> : <a class="reference external" href="http://stackoverflow.com/a/10854034/1431079">http://stackoverflow.com/a/10854034/1431079</a></p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.schedule_constraint">
<code class="descname">schedule_constraint</code><a class="headerlink" href="#stalker.models.task.Task.schedule_constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>An integer number showing the constraint schema for this
task.</p>
<p>Possible values are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>Constrain None</td>
</tr>
<tr class="row-even"><td>1</td>
<td>Constrain Start</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Constrain End</td>
</tr>
<tr class="row-even"><td>3</td>
<td>Constrain Both</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>For convenience use <strong>stalker.models.task.CONSTRAIN_NONE</strong>,
<strong>stalker.models.task.CONSTRAIN_START</strong>,
<strong>stalker.models.task.CONSTRAIN_END</strong>,
<strong>stalker.models.task.CONSTRAIN_BOTH</strong>.</p>
<p>This value is going to be used to constrain the start and end date
values of this task. So if you want to pin the start of a task to a
certain date. Set its <a class="reference internal" href="#stalker.models.task.Task.schedule_constraint" title="stalker.models.task.Task.schedule_constraint"><code class="xref py py-attr docutils literal"><span class="pre">schedule_constraint</span></code></a> value to
<strong>CONSTRAIN_START</strong>. When the task is scheduled by <strong>TaskJuggler</strong>
the start date will be pinned to the <a class="reference internal" href="#stalker.models.task.Task.start" title="stalker.models.task.Task.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a> attribute of
this task.</p>
<p>And if both of the date values (start and end) wanted to be pinned
to certain dates (making the task effectively a <code class="docutils literal"><span class="pre">duration</span></code> task)
set the desired <a class="reference internal" href="#stalker.models.task.Task.start" title="stalker.models.task.Task.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a> and <a class="reference internal" href="#stalker.models.task.Task.end" title="stalker.models.task.Task.end"><code class="xref py py-attr docutils literal"><span class="pre">end</span></code></a> and then set the
<a class="reference internal" href="#stalker.models.task.Task.schedule_constraint" title="stalker.models.task.Task.schedule_constraint"><code class="xref py py-attr docutils literal"><span class="pre">schedule_constraint</span></code></a> to <strong>CONSTRAIN_BOTH</strong>.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.schedule_model">
<code class="descname">schedule_model</code><a class="headerlink" href="#stalker.models.task.Task.schedule_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the schedule model which is going to be used by
<strong>TaskJuggler</strong> while scheduling this Task. It has three possible
values; <strong>effort</strong>, <strong>duration</strong>, <strong>length</strong>. <code class="docutils literal"><span class="pre">effort</span></code> is the
default value. Each value causes this task to be scheduled in
different ways:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>effort</td>
<td>If the <a class="reference internal" href="#stalker.models.task.Task.schedule_model" title="stalker.models.task.Task.schedule_model"><code class="xref py py-attr docutils literal"><span class="pre">schedule_model</span></code></a> attribute is set to
<strong>&#8220;effort&#8221;</strong> then the start and end date values are
calculated so that a resource should spent this much of
work time to complete a Task. For example, a task with
<a class="reference internal" href="#stalker.models.task.Task.schedule_timing" title="stalker.models.task.Task.schedule_timing"><code class="xref py py-attr docutils literal"><span class="pre">schedule_timing</span></code></a> of 4 days, needs 4 working days.
So it can take 4 working days to complete the Task, but it
doesn&#8217;t mean that the task duration will be 4 days. If the
resource works overtime then the task will be finished
before 4 days or if the resource will not be available
(due to a vacation) then the task duration can be much
more.</td>
</tr>
<tr class="row-even"><td>duration</td>
<td>The duration of the task will exactly be equal to
<a class="reference internal" href="#stalker.models.task.Task.schedule_timing" title="stalker.models.task.Task.schedule_timing"><code class="xref py py-attr docutils literal"><span class="pre">schedule_timing</span></code></a> regardless of the resource
availability. So the difference between <a class="reference internal" href="#stalker.models.task.Task.start" title="stalker.models.task.Task.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a>
and <a class="reference internal" href="#stalker.models.task.Task.end" title="stalker.models.task.Task.end"><code class="xref py py-attr docutils literal"><span class="pre">end</span></code></a> attribute values are equal to
<a class="reference internal" href="#stalker.models.task.Task.schedule_timing" title="stalker.models.task.Task.schedule_timing"><code class="xref py py-attr docutils literal"><span class="pre">schedule_timing</span></code></a>. Essentially making the task
duration in calendar days instead of working days.</td>
</tr>
<tr class="row-odd"><td>length</td>
<td>In this model the duration of the task will exactly be
equal to the given length value in working days regardless
of the resource availability. So a task with the
<a class="reference internal" href="#stalker.models.task.Task.schedule_timing" title="stalker.models.task.Task.schedule_timing"><code class="xref py py-attr docutils literal"><span class="pre">schedule_timing</span></code></a> is set to 4 days will be
completed in 4 working days. But again it will not be
always 4 calendar days due to the weekends or non working
days.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.schedule_seconds">
<code class="descname">schedule_seconds</code><a class="headerlink" href="#stalker.models.task.Task.schedule_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the total effort, length or duration in seconds, for
completeness calculation</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.schedule_timing">
<code class="descname">schedule_timing</code><a class="headerlink" href="#stalker.models.task.Task.schedule_timing" title="Permalink to this definition">¶</a></dt>
<dd><p>It is the value of the schedule timing. It is a float
value.</p>
<p>The timing value can either be as Work Time or Calendar Time
defined by the schedule_model attribute. So when the schedule_model
is <cite>duration</cite> then the value of this attribute is in Calendar Time,
and if the schedule_model is either <cite>length</cite> or <cite>effort</cite> then the
value is considered as Work Time.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.schedule_unit">
<code class="descname">schedule_unit</code><a class="headerlink" href="#stalker.models.task.Task.schedule_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>It is the unit of the schedule timing. It is a string
value. And should be one of &#8216;min&#8217;, &#8216;h&#8217;, &#8216;d&#8217;, &#8216;w&#8217;, &#8216;m&#8217;, &#8216;y&#8217;.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.start">
<code class="descname">start</code><a class="headerlink" href="#stalker.models.task.Task.start" title="Permalink to this definition">¶</a></dt>
<dd><p>overridden start getter</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.status">
<code class="descname">status</code><a class="headerlink" href="#stalker.models.task.Task.status" title="Permalink to this definition">¶</a></dt>
<dd><p>The current status of the object.</p>
<p>It is a <a class="reference internal" href="stalker.models.status.Status.html#stalker.models.status.Status" title="stalker.models.status.Status"><code class="xref py py-class docutils literal"><span class="pre">Status</span></code></a> instance which
is one of the Statuses stored in the <code class="docutils literal"><span class="pre">status_list</span></code> attribute
of this object.</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops this task. It is nearly equivalent to deleting this task. But
this will at least preserve the TimeLogs entered for this task. It is
only possible to stop WIP tasks.</p>
<p>You can use <a class="reference internal" href="#stalker.models.task.Task.resume" title="stalker.models.task.Task.resume"><code class="xref py py-meth docutils literal"><span class="pre">resume()</span></code></a> to resume the task.</p>
<p>The only difference between <a class="reference internal" href="#stalker.models.task.Task.hold" title="stalker.models.task.Task.hold"><code class="xref py py-meth docutils literal"><span class="pre">hold()</span></code></a> (other than setting the task
to different statuses) is the schedule info, while the <a class="reference internal" href="#stalker.models.task.Task.hold" title="stalker.models.task.Task.hold"><code class="xref py py-meth docutils literal"><span class="pre">hold()</span></code></a>
method will preserve the schedule info, stop() will set the schedule
info to the current effort.</p>
<p>So if 2 days of effort has been entered for a 4 days task, when stopped
the task effort will be capped to 2 days, thus TaskJuggler will not try
to reserve any resource for this task anymore.</p>
<p>Also, STOP tasks will be ignored in dependency relations.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.tags">
<code class="descname">tags</code><a class="headerlink" href="#stalker.models.task.Task.tags" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of tags attached to this object.</p>
<p>It is a list of <a class="reference internal" href="stalker.models.tag.Tag.html#stalker.models.tag.Tag" title="stalker.models.tag.Tag"><code class="xref py py-class docutils literal"><span class="pre">Tag</span></code></a> instances which shows
the tags of this object</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.task_dependent_of">
<code class="descname">task_dependent_of</code><a class="headerlink" href="#stalker.models.task.Task.task_dependent_of" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of <a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a>s that this one is being depended by.</p>
<p>A CircularDependencyError will be raised when the task dependency
creates a circular dependency which means it is not allowed to create
a dependency for this Task which is depending on another one which in
some way depends to this one again.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.task_depends_to">
<code class="descname">task_depends_to</code><a class="headerlink" href="#stalker.models.task.Task.task_depends_to" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of <a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a>s that this one is depending on.</p>
<p>A CircularDependencyError will be raised when the task dependency
creates a circular dependency which means it is not allowed to create
a dependency for this Task which is depending on another one which in
some way depends to this one again.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.task_id">
<code class="descname">task_id</code><a class="headerlink" href="#stalker.models.task.Task.task_id" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal"><span class="pre">primary_key</span></code> attribute for the <code class="docutils literal"><span class="pre">Tasks</span></code> table used by
SQLAlchemy to map this Task in relationships.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.tasks">
<code class="descname">tasks</code><a class="headerlink" href="#stalker.models.task.Task.tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>A synonym for the <a class="reference internal" href="#stalker.models.task.Task.children" title="stalker.models.task.Task.children"><code class="xref py py-attr docutils literal"><span class="pre">children</span></code></a> attribute used by the
descendants of the <a class="reference internal" href="#stalker.models.task.Task" title="stalker.models.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> class (currently <a class="reference internal" href="stalker.models.asset.Asset.html#stalker.models.asset.Asset" title="stalker.models.asset.Asset"><code class="xref py py-class docutils literal"><span class="pre">Asset</span></code></a>,
<a class="reference internal" href="stalker.models.shot.Shot.html#stalker.models.shot.Shot" title="stalker.models.shot.Shot"><code class="xref py py-class docutils literal"><span class="pre">Shot</span></code></a> and <a class="reference internal" href="stalker.models.sequence.Sequence.html#stalker.models.sequence.Sequence" title="stalker.models.sequence.Sequence"><code class="xref py py-class docutils literal"><span class="pre">Sequence</span></code></a> classes).</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.tickets">
<code class="descname">tickets</code><a class="headerlink" href="#stalker.models.task.Task.tickets" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the tickets referencing this task in their links attribute</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.time_logs">
<code class="descname">time_logs</code><a class="headerlink" href="#stalker.models.task.Task.time_logs" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of <a class="reference internal" href="stalker.models.task.TimeLog.html#stalker.models.task.TimeLog" title="stalker.models.task.TimeLog"><code class="xref py py-class docutils literal"><span class="pre">TimeLog</span></code></a> instances showing who and when has
spent how much effort on this task.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.tjp_abs_id">
<code class="descname">tjp_abs_id</code><a class="headerlink" href="#stalker.models.task.Task.tjp_abs_id" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the calculated absolute id of this task</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.tjp_id">
<code class="descname">tjp_id</code><a class="headerlink" href="#stalker.models.task.Task.tjp_id" title="Permalink to this definition">¶</a></dt>
<dd><p>returns TaskJuggler compatible id</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.to_seconds">
<code class="descname">to_seconds</code><span class="sig-paren">(</span><em>timing</em>, <em>unit</em>, <em>model</em><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>converts the schedule values to seconds, depending on to the
schedule_model the value will differ. So if the schedule_model is
&#8216;effort&#8217; or &#8216;length&#8217; then the schedule_time and schedule_unit values
are interpreted as work time, if the schedule_model is &#8216;duration&#8217; then
the schedule_time and schedule_unit values are considered as calendar
time.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.to_tjp">
<code class="descname">to_tjp</code><a class="headerlink" href="#stalker.models.task.Task.to_tjp" title="Permalink to this definition">¶</a></dt>
<dd><p>TaskJuggler representation of this task</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.total_logged_seconds">
<code class="descname">total_logged_seconds</code><a class="headerlink" href="#stalker.models.task.Task.total_logged_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>The total effort spent for this Task. It is the sum of all the
TimeLogs recorded for this task as seconds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns int:</th><td class="field-body">An integer showing the total seconds spent.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.total_seconds">
<code class="descname">total_seconds</code><a class="headerlink" href="#stalker.models.task.Task.total_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the duration as seconds</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.type">
<code class="descname">type</code><a class="headerlink" href="#stalker.models.task.Task.type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of the object.</p>
<p>It is an instance of <a class="reference internal" href="stalker.models.type.Type.html#stalker.models.type.Type" title="stalker.models.type.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a> with a proper
<a class="reference internal" href="stalker.models.type.Type.html#stalker.models.type.Type.target_entity_type" title="stalker.models.type.Type.target_entity_type"><code class="xref py py-attr docutils literal"><span class="pre">Type.target_entity_type</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.type_id">
<code class="descname">type_id</code><a class="headerlink" href="#stalker.models.task.Task.type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the <a class="reference internal" href="stalker.models.type.Type.html#stalker.models.type.Type" title="stalker.models.type.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a> of this entity. Mainly used by
SQLAlchemy to create a Many-to-One relates between SimpleEntities and
Types.</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.update_parent_statuses">
<code class="descname">update_parent_statuses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.update_parent_statuses" title="Permalink to this definition">¶</a></dt>
<dd><p>updates the parent statuses of this task if any</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.update_schedule_info">
<code class="descname">update_schedule_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.update_schedule_info" title="Permalink to this definition">¶</a></dt>
<dd><p>updates the total_logged_seconds and schedule_seconds attributes by
using the children info and triggers an update on every children</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.update_status_with_children_statuses">
<code class="descname">update_status_with_children_statuses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.update_status_with_children_statuses" title="Permalink to this definition">¶</a></dt>
<dd><p>updates the task status according to its children statuses</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.update_status_with_dependent_statuses">
<code class="descname">update_status_with_dependent_statuses</code><span class="sig-paren">(</span><em>removing=None</em><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.update_status_with_dependent_statuses" title="Permalink to this definition">¶</a></dt>
<dd><p>updates the status by looking at the dependent tasks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>removing</strong> &#8211; The item that is been removing right now, used for the
remove event to overcome the update issue.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.updated_by">
<code class="descname">updated_by</code><a class="headerlink" href="#stalker.models.task.Task.updated_by" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a> who has updated this object.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.updated_by_id">
<code class="descname">updated_by_id</code><a class="headerlink" href="#stalker.models.task.Task.updated_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the <a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a> who has updated this entity.</p>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.versions">
<code class="descname">versions</code><a class="headerlink" href="#stalker.models.task.Task.versions" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of <a class="reference internal" href="stalker.models.version.Version.html#stalker.models.version.Version" title="stalker.models.version.Version"><code class="xref py py-class docutils literal"><span class="pre">Version</span></code></a> instances showing the files created
for this task.</p>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.walk_dependencies">
<code class="descname">walk_dependencies</code><span class="sig-paren">(</span><em>method=1</em><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.walk_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Walks the dependencies of this task</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>method</strong> &#8211; The walk method, 0: Depth First, 1: Breadth First</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="stalker.models.task.Task.walk_hierarchy">
<code class="descname">walk_hierarchy</code><span class="sig-paren">(</span><em>method=0</em><span class="sig-paren">)</span><a class="headerlink" href="#stalker.models.task.Task.walk_hierarchy" title="Permalink to this definition">¶</a></dt>
<dd><p>Walks the hierarchy of this task.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>method</strong> &#8211; The walk method, 0: Depth First, 1: Breadth First</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="stalker.models.task.Task.watchers">
<code class="descname">watchers</code><a class="headerlink" href="#stalker.models.task.Task.watchers" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of <a class="reference internal" href="stalker.models.auth.User.html#stalker.models.auth.User" title="stalker.models.auth.User"><code class="xref py py-class docutils literal"><span class="pre">User</span></code></a>s watching this Task.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="stalker.models.tag.Tag.html"
                        title="previous chapter">stalker.models.tag.Tag</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="stalker.models.task.TaskDependency.html"
                        title="next chapter">stalker.models.task.TaskDependency</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="stalker.models.task.TaskDependency.html" title="stalker.models.task.TaskDependency"
             >next</a> |</li>
        <li class="right" >
          <a href="stalker.models.tag.Tag.html" title="stalker.models.tag.Tag"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Stalker 0.2.13.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2009-2014, Stalker authors and contributors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>